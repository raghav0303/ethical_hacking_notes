app process name jakhar.aseem.diva
- to find process id of the required process(if we filter the log to the specific ones we want to see then it is really helpful)
	- $ adb shell ps | grep -i "diva"
	- Output : u0_a130        3290    268 12999716 208060 0                  0 S jakhar.aseem.diva
	- process id - 3290
- to find the log related to following data
	- $ adb logcat | grep (process_id)
	- output - 11-23 22:20:12.451  3290  3290 E diva-log: Error while processing transaction with credit card: 023456789
	- here credit card is being logged which is vulnerable
- jadx gui has the code in LogActivity class for it. we can have a global search for text to find related code for the error.

<h1>Hardcoding Issues Part 1</h1>
- right click on a name, function, class or variable to see find usage option in jadx-gui.
- since mapping of things to their origin and for seeing the logic of the code of the page they are in by searching text found in app in jadx-gui does'nt show much context between things. we can use error messages or something related to functtionality of the application that is dynamic and not static text. this will help us in reaching the logic code much more easily.
- hard coded value - vendorsecret key as the actual vendor's secret key
	- code snnipet - if (hckey.getText().toString().equals("vendorsecretkey")) {


<h1>Insecure Data Storage - Part 1</h1>
- on saving username and password
	- toast message - 3rd party credentials saved successfully!
	- we search for it in jadx gui
	- code
		-  public void saveCredentials(View view) {  
		        SharedPreferences spref = PreferenceManager.getDefaultSharedPreferences(this);  
		        SharedPreferences.Editor spedit = spref.edit();  
		        EditText usr = (EditText) findViewById(R.id.ids1Usr);  
		        EditText pwd = (EditText) findViewById(R.id.ids1Pwd);  
		        spedit.putString("user", usr.getText().toString());  
		        spedit.putString("password", pwd.getText().toString());  
		        spedit.commit();  
		        Toast.makeText(this, "3rd party credentials saved successfully!", 0).show();  
			}
	- so data is being stored in shared preferences. this stored data can be seen in xml file stored in shared preferencec of the application
- we use adb for viewing the stored data
	- code
		- $adb shell
		- $su
		- \#cd data/data
		- \#ls
			- output (something like this)- 
						com.android.wallpaperbackup
						com.android.wallpapercropper
						com.android.wallpaperpicker
						com.android.webview
						com.android.wifi.resources
						jakhar.aseem.diva
						org.chromium.webview_shell
		- we see jakhar.aseem.diva which is the name of the process for our running application
			- \#cd jakhar.aseem.diva
			- \#ls
				- (output) app_textures  cache       databases     uinfo470952070677313101tmp
					app_webview   code_cache  shared_prefs
			- \#cd shared_prefs
			- \#ls
				- WebViewChromiumPrefs.xml  jakhar.aseem.diva_preferences.xml
			- \# cat jakhar.aseem.diva_preferences.xml
	output
```xml
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <string name="password">team minato</string>
    <string name="user">obito</string>
</map>

```

we found our entered text as 'obito' and 'team minato'

<h1>Insecure Data Storage</h1>
- on saving username and password we see "3rd party credentials saved successfully!"
- we search it in jadx-gui
	- ```java
	  public class InsecureDataStorage2Activity extends AppCompatActivity {  
    private SQLiteDatabase mDB;  
  
    @Override // android.support.v7.app.AppCompatActivity, android.support.v4.app.FragmentActivity, android.support.v4.app.BaseFragmentActivityDonut, android.app.Activity  
    protected void onCreate(Bundle savedInstanceState) throws SQLException {  
        super.onCreate(savedInstanceState);  
        try {  
            this.mDB = openOrCreateDatabase("ids2", 0, null);  
            this.mDB.execSQL("CREATE TABLE IF NOT EXISTS myuser(user VARCHAR, password VARCHAR);");  
        } catch (Exception e) {  
            Log.d("Diva", "Error occurred while creating database: " + e.getMessage());  
        }  
        setContentView(R.layout.activity_insecure_data_storage2);  
    }  
  
    public void saveCredentials(View view) throws SQLException {  
        EditText usr = (EditText) findViewById(R.id.ids2Usr);  
        EditText pwd = (EditText) findViewById(R.id.ids2Pwd);  
        try {  
            this.mDB.execSQL("INSERT INTO myuser VALUES ('" + usr.getText().toString() + "', '" + pwd.getText().toString() + "');");  
            this.mDB.close();  
        } catch (Exception e) {  
            Log.d("Diva", "Error occurred while inserting into database: " + e.getMessage());  
        }  
        Toast.makeText(this, "3rd party credentials saved successfully!", 0).show();  
    }  
}
	  ```
	- we get to know that it the data is being stored in an sqlite database.
	- commands to view data
		- ```
		  #adb shell
		  #su
		  #cd data/data/jakhar.aseem.diva/databases
		  #ls
		  output - divanotes.db  divanotes.db-journal  ids2  ids2-journal
		  from our code above, we know that database used for storing the user and           password is 'ids2'. table is 'myuser'
		  
		  #sqlite3 ids2
		  
		  sqlite>.tables
		  output: android_metadata  myuser
		  
		  sqlite>select * from myuser;
		  output:(here if we save the credentials in app and close and again open            the app then the credentials will be displayed in this output)
		  sfdv|dsfsdfv
		  obito|minato
		  ```

<h1>Insecure Data Storage - Part3</h1>
- on saving username and password we see "3rd party credentials saved successfully!"
- we search it in jadx-gui
![[Screenshot_2025-11-26_05-03-07.png]]

- We see that 
	- File ddir = new File(getApplicationInfo().dataDir);
- on searching we get the command
	![[Pasted image 20251126050625.png]]
		- this command gets us dataDir path using dumpsys. 
		- dumpsys - This is a powerful, built-in Android tool that "dumps" diagnostic information about all the system services running on the device. The output is usually very verbose and extensive.
- using adb shell and subsequesnt commands we got to the found path
![[Pasted image 20251126051010.png]]
- In the code in jadx gui uninfo named temporary file is being created for storing the username and password.
	- File uinfo = File.createTempFile("uinfo", "tmp", ddir);
- in ls output above there are files starting with uinfo and ending with tmp
	- if we do ls -l we see that they are files so we cat to see data inside.
![[Pasted image 20251126051604.png]]
![[Pasted image 20251126051649.png]]

<h1>Insecure Data Storage - Part 4</h1>
```
find . -name ".uinfo.txt"
```
- the find command shows the absolute path of the command as well unlike ls command which can be used to find a file or folder with combining ls and grep ($ls -alR | grep -i ".uinfo.txt")but still it will not be telling exactly where the file was found.

<h1>Input Validation Issues - Part 1</h1>
- sql injection ' or 1=1--

![[Pasted image 20251126064612.png]]

<h1>Access Control Issue - Part 1</h1>
- activity - pages, action - to be defined by us, intent - in between one page to next, calls another activity
- We click on "View API credentials"
- we see credentials in a new page(activity) showing credentials.
- analyzing the code in AccessControl1Activity we see that an action is being called using an intent rather that directly calling api credentials activity(that credentials page)
![[Pasted image 20251126211555.png]]


- actions are defined in AndroidManifest.xml file. we see there.
	- For actions, AndroidManifest ‚Üí declares capability; Code ‚Üí triggers or specifies action.
![[Pasted image 20251126211724.png]]

- so intent-filter is used with no export set to true or false so we can take it as true by default(pre-Android 12 default). which means that this action is exported outside application and can be triggered from any where.
- VIEW_CREDS action calls APICredsActivity. we see its code
![[Pasted image 20251126212004.png]]

we can see the credentials in code that we see in the page after clicking 'View API Credentials' button.

- to exploit this vulnerability
	- in cmd we enter the command
		- $adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS
	- now automatically the credentials screen starts being displayed.
	- so we exploited the vulnerability and invoked credentials screen without using the 'View API Credentials'  button.
	- am - activity manager tool in android
	- start - is a command to launch an **Activity**
	- -a  - specifies the **action** for the `Intent`
	- This tells the system: ‚ÄúStart the activity that can handle this action.‚Äù

![[Pasted image 20251126212239.png]]

![[Pasted image 20251126212309.png]]
# üì± Android Fundamentals: Activity, Intent, and Why They‚Äôre Needed

## 1. **What is an Activity?**

**Activity = a single screen in an Android app**

Examples:

- Login screen
    
- Home screen
    
- Settings screen
    
- ‚ÄúView API Credentials‚Äù screen
    

Every time a new screen opens, Android launches a new Activity.

### **Why Activities are needed**

- Apps need multiple screens
    
- Android manages screen lifecycle (onCreate, onStart, etc.)
    
- Handles memory, rotation, background/foreground states
    
- Keeps apps stable and consistent
    

---

## 2. **What is an Intent?**

**Intent = a message/request asking Android to do something.**

Examples of what an Intent can do:

- Open an Activity
    
- Start a Service
    
- Open browser/camera/gallery
    
- Send email/SMS
    
- Launch another app
    

### **Two Types of Intents**

#### **(1) Explicit Intent**

You specify which Activity to open:

`Intent i = new Intent(this, LoginActivity.class); startActivity(i);`

#### **(2) Implicit Intent**

You specify an _action_, not a specific Activity:
(an implicit intent _requires_ a matching `<intent-filter>` in the manifest)

`Intent i = new Intent(); i.setAction("jakhar.aseem.diva.action.VIEW_CREDS"); startActivity(i);`

Android looks for an Activity with a matching `intent-filter`.

---

## 3. **Why Intents are needed**

Without intents, Android apps could NOT:

- Navigate between screens
    
- Start background tasks
    
- Share data between apps
    
- Open camera/gallery/browser
    
- Respond to system actions
    
- Communicate between components
    

**Android is built on intent-based communication.**

---

## 4. **Why DIVA App Uses an Intent Instead of Direct Code**

In DIVA, this code:

`Intent i = new Intent(); i.setAction("jakhar.aseem.diva.action.VIEW_CREDS"); startActivity(i);`

opens the Activity that shows API credentials.

Developers _could_ have simply written:

`new Intent(this, APICredsActivity.class)`

But they didn‚Äôt ‚Äî **on purpose**.

### The reason:

To teach a **security vulnerability** called **component exposure**.

- Implicit intents require an `intent-filter`
    
- An Activity with an `intent-filter` becomes **exported by default**
    
- Exported Activities can be triggered by **any other app**
    
- So API credentials can be leaked externally
    

This is deliberately insecure for training.

---

## 5. **Full Concept Summary**

| Concept             | Meaning                                       | Why Needed                                      |
| ------------------- | --------------------------------------------- | ----------------------------------------------- |
| **Activity**        | A screen in the app                           | Multiple screens + lifecycle mgmt               |
| **Intent**          | A message asking Android to perform an action | Nav, services, sharing, inter-app communication |
| **Explicit Intent** | Opens a specific Activity                     | Internal navigation                             |
| **Implicit Intent** | Opens _any_ Activity that matches an action   | Inter-app communication                         |
| **Intent-filter**   | Declares which actions an Activity accepts    | Required for implicit intents                   |
| **exported=true**   | Other apps can access this component          | Needed for implicit intents (and dangerous)     |

---

## 6. **Why DIVA Combines Activities + Intents**

To teach:

> **If you expose an Activity through an intent-filter, external apps can trigger it and steal sensitive data.**

DIVA intentionally:

- Puts API credentials in an Activity
    
- Uses an implicit intent
    
- That Activity has an intent-filter
    
- Thus it becomes exported
    
- Thus it can be accessed externally
    

This is the core vulnerability you are meant to understand.


### ‚úÖ **Yes ‚Äî the `action` in an intent-filter can be called from BOTH inside and outside the app.**

But **whether it actually _will_ be callable from outside** depends on one thing:

# üî• **Is the Activity exported or not?**

---

# ‚úÖ **Case 1: Activity has `<intent-filter>` (like in DIVA)**

### üëâ Then by default (pre-Android 12):

`android:exported="true"`

This means:

### ‚úîÔ∏è Inside the app ‚Üí YES, you can call it

`Intent i = new Intent(); i.setAction("jakhar.aseem.diva.action.VIEW_CREDS"); startActivity(i);`

### ‚úîÔ∏è Outside the app ‚Üí YES, other apps can call it

`adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS`

Or a malicious app can also do:

`Intent i = new Intent("jakhar.aseem.diva.action.VIEW_CREDS"); startActivity(i);`

### üëâ This is why DIVA‚Äôs API credentials leak.

---

# ‚úÖ **Case 2: Activity uses intent-filter AND sets `exported="false"` (Android 12+)**

`<activity     android:name=".APICredsActivity"     android:exported="false">     <intent-filter>         <action android:name="jakhar.aseem.diva.action.VIEW_CREDS"/>     </intent-filter> </activity>`

Then:

### ‚úîÔ∏è Inside your app ‚Üí can call the action

### ‚ùå Outside apps ‚Üí cannot call it

Android will block the request.

---

# ‚ùó Key Rule to Remember

### **An intent-filter does NOT guarantee external accessibility by itself.**

It only becomes externally accessible if the Activity is **exported**.

---

# üìå So the real logic is:

|Has Intent-Filter|Exported?|Can be Triggered from Inside|Can be Triggered from Outside|
|---|---|---|---|
|Yes|True|‚úîÔ∏è Yes|‚úîÔ∏è Yes|
|Yes|False|‚úîÔ∏è Yes|‚ùå No|
|No|True/False|‚úîÔ∏è Yes (explicit intent)|‚ùå No|

---

# üìå Why did DIVA's Activity get triggered from outside?

Because:

- It has an `<intent-filter>`
    
- Before Android 12 ‚Üí any Activity with an intent-filter becomes **exported automatically**
    
- So external apps (and ADB) can call it
    

This is the vulnerability.

---

# üéØ Final Answer (Simple)

### ‚úîÔ∏è If the Activity is exported ‚Üí action can be called inside AND outside

### ‚úîÔ∏è If the Activity is NOT exported ‚Üí action can only be called inside

### ‚úîÔ∏è Within your app you can always call the action

### ‚ùå Outside your app you can call it **only if exported=true**


<h1>Access Control Issue - Part 2</h1>
- similar to previous, intent-filter is used but when we call the activity from outside, using `adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS2` we get this screen


![[Pasted image 20251127062105.png]]

- so we see the code and find that there is chk_pin parameter extra to the previous question
![[Pasted image 20251127074553.png]]

- chk_pin is boolean so we can turn it to false externally. In logic, if chk_pin is true then the pin will be asked in app.
- in command name chk_pin is not used. in res/values/strings.xml we define parameter with name check_pin so that is used.
![[Pasted image 20251127062003.png]]
- command
	- `adb shell am start -n jakhar.aseem.diva/.APICreds2Activity --ez check_pin false`
	- -n  - 	This flag specifies the name of the component to target directly, rather than letting Android resolve a general intent.
	- --ez  - This is a flag used by the `am start` utility to define an extra parameter that is a zero (boolean).
	- `jakhar.aseem.diva/.APICreds2Activity` - This is the specific application package name (jakhar.asem.diva) and the target activity name (.APICreds2Activity) we wanted to launch.



#drozer
Drozer can also be used for this but was not working for me

- we start drozer agent in mobile. Installed an apk file for it. port is 31415
![[Pasted image 20251127065653.png]]

- We see ip of our device (in wifi settings) and connect drozer to it
	- `drozer console connect --server 10.0.2.16:31415`
	- If this does'nt work then (sometimes we need to turn off and again on embedded server in drozer application in emulator for this to work). both commands are necessary. first adb one and then starting drozer
		- `adb forward tcp:31415 tcp:31415`
		- `drozer console connect --server 127.0.0.1:31415`
	- after getting connected we run the command
		- `run app.activity.start --component jakhar.aseem.diva jakhar.aseem.diva.APICreds2Activity --extra boolean check_pin false`
![[Pasted image 20251127065438.png]]

![[Pasted image 20251127065630.png]]



![[Pasted image 20251127073609.png]]